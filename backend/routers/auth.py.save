# routers/auth.py
import requests
from fastapi import APIRouter, HTTPException, Depends, status, Request # Import Request
from fastapi.responses import JSONResponse
#from keycloak import KeycloakOpenID
from config import KEYCLOAK_CONFIG
from models.base_models import LoginRequest
(frdenv) ubuntu@dev-instance:~$ cd FRMPipeline/backend/
(frdenv) ubuntu@dev-instance:~/FRMPipeline/backend$ uvicorn main:app --host 0.0.0.0 --port 9000 --reload
INFO:     Will watch for changes in these directories: ['/home/ubuntu/FRMPipeline/backend']
INFO:     Uvicorn running on http://0.0.0.0:9000 (Press CTRL+C to quit)
INFO:     Started reloader process [2402593] using StatReload
Process SpawnProcess-1:
Traceback (most recent call last):
  File "/usr/lib/python3.13/multiprocessing/process.py", line 313, in _bootstrap
    self.run()
    ~~~~~~~~^^
  File "/usr/lib/python3.13/multiprocessing/process.py", line 108, in run
    self._target(*self._args, **self._kwargs)
    ~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/ubuntu/frdenv/lib/python3.13/site-packages/uvicorn/_subprocess.py", line 80, in subprocess_started
    target(sockets=sockets)
    ~~~~~~^^^^^^^^^^^^^^^^^
  File "/home/ubuntu/frdenv/lib/python3.13/site-packages/uvicorn/server.py", line 66, in run
    return asyncio.run(self.serve(sockets=sockets))
           ~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/usr/lib/python3.13/asyncio/runners.py", line 195, in run
    return runner.run(main)
           ~~~~~~~~~~^^^^^^
  File "/usr/lib/python3.13/asyncio/runners.py", line 118, in run
    return self._loop.run_until_complete(task)
           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^^^^^^
  File "/usr/lib/python3.13/asyncio/base_events.py", line 725, in run_until_complete
    return future.result()
           ~~~~~~~~~~~~~^^
  File "/home/ubuntu/frdenv/lib/python3.13/site-packages/uvicorn/server.py", line 70, in serve
    await self._serve(sockets)
  File "/home/ubuntu/frdenv/lib/python3.13/site-packages/uvicorn/server.py", line 77, in _serve
    config.load()
    ~~~~~~~~~~~^^
  File "/home/ubuntu/frdenv/lib/python3.13/site-packages/uvicorn/config.py", line 435, in load
    self.loaded_app = import_from_string(self.app)
                      ~~~~~~~~~~~~~~~~~~^^^^^^^^^^
  File "/home/ubuntu/frdenv/lib/python3.13/site-packages/uvicorn/importer.py", line 19, in import_from_string
    module = importlib.import_module(module_str)
  File "/usr/lib/python3.13/importlib/__init__.py", line 88, in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ~~~~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "<frozen importlib._bootstrap>", line 1387, in _gcd_import
  File "<frozen importlib._bootstrap>", line 1360, in _find_and_load
  File "<frozen importlib._bootstrap>", line 1331, in _find_and_load_unlocked
  File "<frozen importlib._bootstrap>", line 935, in _load_unlocked
  File "<frozen importlib._bootstrap_external>", line 1026, in exec_module
  File "<frozen importlib._bootstrap>", line 488, in _call_with_frames_removed
  File "/home/ubuntu/FRMPipeline/backend/main.py", line 16, in <module>
    from routers import (
    ...<14 lines>...
    )
  File "/home/ubuntu/FRMPipeline/backend/routers/auth.py", line 18, in <module>
    def get_keycloak_openid_instance(request: Request) -> KeycloakOpenID:
                                                          ^^^^^^^^^^^^^^
NameError: name 'KeycloakOpenID' is not defined



# Imports for CaseEntryMatcher and ThreadPoolExecutor (for matcher dependency)
from db.matcher import CaseEntryMatcher # Import CaseEntryMatcher
from concurrent.futures import ThreadPoolExecutor # For type hinting executor

from typing import Optional, Any, Dict, List, Annotated

router = APIRouter()

# Dependency to get the KeycloakOpenID instance (from main.py's app.state)
def get_keycloak_openid_instance(request: Request) -> KeycloakOpenID:
    return request.app.state.keycloak_openid

# Dependency to get the CaseEntryMatcher instance (from main.py's app.state)
def get_case_matcher_instance(request: Request) -> CaseEntryMatcher:
    return CaseEntryMatcher(executor=request.app.state.executor)

# Dependency to get the ThreadPoolExecutor (from main.py's app.state)
def get_executor_dependency(request: Request) -> ThreadPoolExecutor:
    return request.app.state.executor

# NEW: Explicit OPTIONS route for /api/login to handle CORS preflight
@router.options("/api/login")
async def options_login_api():
    """Handles CORS preflight requests for the /api/login endpoint."""
    return {"message": "OK"} # A simple 200 OK response

@router.post("/api/login")
async def login_for_access_token(
    form_data: LoginRequest,
    keycloak_openid_instance: Annotated[KeycloakOpenID, Depends(get_keycloak_openid_instance)],
    matcher: Annotated[CaseEntryMatcher, Depends(get_case_matcher_instance)], # FIX: Inject matcher
    executor: Annotated[ThreadPoolExecutor, Depends(get_executor_dependency)] # FIX: Inject executor
) -> Dict[str, str]: # Return type will expand to include user_type
    """
    Authenticates a user and returns JWT access token, refresh token, and user_type.
    """
    try:
        token_response = keycloak_openid_instance.token(
            username=form_data.username,
            password=form_data.password,
            grant_type='password'
        )

        if not token_response or "access_token" not in token_response:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Incorrect username or password",
                headers={"WWW-Authenticate": "Bearer"},
            )
        
        access_token = token_response["access_token"]
        refresh_token = token_response.get("refresh_token")
        
        # FIX: Decode token to get username (similar to get_current_username)
        # This is temporary to get username from token for user_type lookup.
        # In a real scenario, you might have a dedicated service for this.
        # This logic is complex because keycloak_openid_instance.decode_token needs a public key or client secret.
        # We'll use the secret from config for simplicity here.
        
        # You will need your KEYCLOAK_CONFIG imported here for jwt.decode
        from config import KEYCLOAK_CONFIG # Ensure this import is at the top

        try:
            # Decode the token (needs secret key or public key from config)
            # This is a bit redundant as keycloak_openid_instance.token already validates
            # but we need username from claims
            decoded_token = keycloak_openid_instance.decode_token(access_token)
            username_from_token: str = decoded_token.get("preferred_username") or decoded_token.get("sub")
            if not username_from_token:
                raise ValueError("Username claim missing in token.")

            # FIX: Fetch user_type from db/matcher.py
            user_type = await matcher.fetch_user_type(username_from_token) # Call fetch_user_type
            if user_type is None:
                # If user is in Keycloak but not in your user_table, decide behavior
                print(f"WARNING: User '{username_from_token}' logged in via Keycloak but not found in user_table. Defaulting to 'others' type.", flush=True)
                user_type = 'others' # Default role if not found in user_table

        except Exception as e:
            print(f"Error decoding token or fetching user_type during login: {e}", flush=True)
            user_type = 'others' # Default to a safe role on error
        
        # FIX: Include user_type in the response
        return JSONResponse(content={
            "access_token": access_token,
            "token_type": "bearer",
            "refresh_token": refresh_token,
            "user_type": user_type, # Include user_type
            "username": username_from_token # Also include username for frontend convenience
        })

    except HTTPException:
        raise
    except requests.exceptions.RequestException as e:
        print(f"Keycloak connection error during login: {e}")
        import traceback
        traceback.print_exc()
        raise HTTPException(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            detail="Authentication service unavailable."
        )
    except Exception as e:
        print(f"Unexpected error during login: {e}")
        import traceback
        traceback.print_exc()
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="An internal server error occurred during login."
        )
