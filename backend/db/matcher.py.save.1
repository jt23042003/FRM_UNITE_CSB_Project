# db/matcher.py
import psycopg2
from psycopg2.extras import RealDictCursor
from datetime import date, datetime, time # Added datetime, time for new table defaults
from typing import Dict, Any, List, Optional, Union, Annotated
import json
import requests
import asyncio
from concurrent.futures import ThreadPoolExecutor
import random
import uuid
import re

from .connection import get_db_connection, get_db_cursor
# Ensure all necessary models are imported from base_models.py
from models.base_models import CaseEntryData, I4CData, TransactionData, BeneficiaryData, PotentialSuspectAccountData, CaseMainUpdateData 
from config import DB_CONNECTION_PARAMS, ERROR_LOG_DIR # Ensure ERROR_LOG_DIR is defined in config.py

from fastapi import UploadFile

class CaseNotFoundError(Exception):
    pass

# --- Standalone Asynchronous Database Helper Functions ---
async def _execute_sync_op_standalone(executor: ThreadPoolExecutor, func, *args, **kwargs):
    return await asyncio.get_running_loop().run_in_executor(executor, func, *args, **kwargs)

async def fetch_transactions_from_db(executor: ThreadPoolExecutor, ack_no: str, from_date: date, to_date: date, type: str):
    def _sync_fetch():
        with get_db_connection() as conn:
            with get_db_cursor(conn) as cur:
                account_col = 'account_number' if type == 'victim' else 'to_account'
                cur.execute(f"""
                    SELECT {account_col}
                    FROM case_entry_form
                    WHERE ack_no = %s
                """, (ack_no,))
                result = cur.fetchone()

                if not result or not result.get(account_col):
                    return []

                account_num = result.get(account_col)
                if not isinstance(account_num, (int, float, str)) or (isinstance(account_num, str) and not re.fullmatch(r'\d+', str(account_num).strip())):
                    return []

                query = f"SELECT txn_date, descr, txn_ref, amount, txn_type FROM txn WHERE acct_num = %s AND txn_date BETWEEN %s AND %s ORDER BY txn_date DESC, txn_time DESC;"
                cur.execute(query, (account_num, from_date, to_date))
                raw_transactions = cur.fetchall()

                processed_transactions = []
                for txn in raw_transactions:
                    withdrawal = None
                    deposit = None
                    if txn.get('txn_type') == 'Debit':
                        withdrawal = txn.get('amount')
                    elif txn.get('txn_type') == 'Credit':
                        deposit = txn.get('amount')

                    processed_transactions.append({
                        'date': txn.get('txn_date'),
                        'narration': txn.get('descr'),
                        'refNo': txn.get('txn_ref'),
                        'valueDate': txn.get('txn_date'),
                        'withdrawal': withdrawal,
                        'deposit': deposit,
                        'closingBalance': None
                    })
                return processed_transactions
    return await _execute_sync_op_standalone(executor, _sync_fetch)

async def insert_uploaded_document(executor: ThreadPoolExecutor, case_id: int, document_type: str, original_filename: str, saved_filepath: str, file_mime_type: str, comment: Optional[str] = None, uploaded_by: Optional[str] = None):
    def _sync_insert():
        with get_db_connection() as conn:
            with get_db_cursor(conn) as cur:
                cur.execute(
                    """
                    INSERT INTO public.case_documents
                        (case_id, document_type, original_filename, file_location, file_mime_type, uploaded_by, comment)
                    VALUES (%s, %s, %s, %s, %s, %s, %s)
                    RETURNING id, original_filename, document_type, file_location, uploaded_at, uploaded_by, comment, file_mime_type;
                    """,
                    (case_id, document_type, original_filename, saved_filepath, file_mime_type, uploaded_by, comment)
                )
                new_doc = cur.fetchone()
                conn.commit()
                return new_doc
    return await _execute_sync_op_standalone(executor, _sync_insert)

async def get_uploaded_documents(executor: ThreadPoolExecutor, case_id: int) -> List[Dict[str, Any]]:
    def _sync_get_docs():
        with get_db_connection() as conn:
            with get_db_cursor(conn) as cur:
                cur.execute(
                    """
                    SELECT id, document_type, original_filename, file_location, uploaded_by, comment, uploaded_at, file_mime_type
                    FROM public.case_documents WHERE case_id = %s ORDER BY uploaded_at DESC
                    """,
                    (case_id,)
                )
                docs = cur.fetchall()
                return docs
    return await _execute_sync_op_standalone(executor, _sync_get_docs)

async def get_document_by_id(executor: ThreadPoolExecutor, document_id: int) -> Optional[Dict[str, Any]]:
    def _sync_get_document():
        with get_db_connection() as conn:
            with get_db_cursor(conn) as cur:
                cur.execute("SELECT file_location, original_filename, file_mime_type FROM public.case_documents WHERE id = %s", (document_id,))
                return cur.fetchone()
    return await _execute_sync_op_standalone(executor, _sync_get_document)

# Note: save_or_update_decision and get_decision now refer to case_history, not case_decisions
async def save_or_update_decision(executor: ThreadPoolExecutor, case_id: int, data: Dict[str, Any]): # Changed ack_no to case_id
    def _sync_save_decision():
        with get_db_connection() as conn:
            with get_db_cursor(conn) as cur:
                db_data_for_insert_update = {
                    "remarks": data.get('comments'), # Map comments to remarks
                    "short_dn": data.get('riskScore'), # Using riskScore for short_dn
                    "long_dn": data.get('systemExplanation'), # Using systemExplanation for long_dn
                    "decision_type": data.get('systemRecommendation'), # Using systemRecommendation for decision_type
                    "updated_by": data.get('assignedEmployee'), # Map assignedEmployee to updated_by
                }
                
                # Filter out None values. Empty strings are also treated as None.
                filtered_db_data = {k: v if v != '' else None for k, v in db_data_for_insert_update.items()}
                
                db_columns_list = []
                db_values_list = []
                update_set_parts = []

                db_columns_list.append("case_id") # PK for new decision table is case_id
                db_values_list.append(case_id)

                for key, value in filtered_db_data.items():
                    # For decision_type, short_dn, long_dn, these are already snake_case
                    # For other fields, ensure they match DB columns
                    db_col_name = key 
                    if db_col_name not in db_columns_list: # Avoid duplicating case_id
                        db_columns_list.append(db_col_name)
                        db_values_list.append(value)
                    
                    update_set_parts.append(f"{db_col_name} = EXCLUDED.{db_col_name}")

                update_set_parts.append("created_time = NOW()") # Use created_time as update timestamp in case_history

                insert_cols_str = ", ".join(db_columns_list)
                insert_placeholders_str = ", ".join(["%s"] * len(db_columns_list))
                update_set_str = ", ".join(update_set_parts)

                cur.execute(
                    f"""
                    INSERT INTO public.case_history ({insert_cols_str})
                    VALUES ({insert_placeholders_str})
                    ON CONFLICT (case_id) DO UPDATE SET
                        {update_set_str}
                    RETURNING *;
                    """,
                    tuple(db_values_list)
                )
                
                updated_decision_record = cur.fetchone()
                conn.commit()
                print(f"✅ Decision record for case_id {case_id} saved/updated in case_history.", flush=True)

                return updated_decision_record
    return await _execute_sync_op_standalone(executor, _sync_save_decision)

async def get_decision(executor: ThreadPoolExecutor, case_id: int) -> Optional[Dict[str, Any]]: # Changed ack_no to case_id
    def _sync_get_decision():
        with get_db_connection() as conn:
            with get_db_cursor(conn) as cur:
                cur.execute("SELECT * FROM public.case_history WHERE case_id = %s", (case_id,)) # Query case_history
                decision_record_db = cur.fetchone()
                
                if not decision_record_db:
                    return None
                
                # Map DB snake_case keys to frontend camelCase keys for decision_history
                mapped_decision = {
                    "caseId": decision_record_db.get('case_id'),
                    "riskScore": decision_record_db.get('short_dn'), # Map short_dn to riskScore
                    "triggeringRules": None, # Not directly available from case_history
                    "comments": decision_record_db.get('remarks'), # Map remarks to comments
                    "decisionAction": decision_record_db.get('decision_type'), # Map decision_type to decisionAction
                    "assignedEmployee": decision_record_db.get('updated_by'), # Map updated_by to assignedEmployee
                    "auditTrail": None, # AuditTrail not directly stored here
                    "systemRecommendation": decision_record_db.get('decision_type'), # Map decision_type to systemRecommendation
                    "systemExplanation": decision_record_db.get('long_dn'), # Map long_dn to systemExplanation
                    "lastUpdatedAt": decision_record_db.get('created_time').isoformat() if decision_record_db.get('created_time') else None,
                }
                return mapped_decision
    return await _execute_sync_op_standalone(executor, _sync_get_decision)

# --- CaseEntryMatcher Class (Core logic for both old and new systems) ---
class CaseEntryMatcher:
    def __init__(self, executor: ThreadPoolExecutor):
        self.executor = executor

    async def _execute_sync_db_op(self, func, *args, **kwargs):
        return await asyncio.get_running_loop().run_in_executor(self.executor, func, *args, **kwargs)

    # UPDATED METHOD: insert_into_case_main (new system's primary case table)
    async def insert_into_case_main(self, case_type: str, source_ack_no: str, cust_id: Optional[str] = None, 
                                    acc_num: Optional[str] = None, source_bene_accno: Optional[str] = None, 
                                    is_operational: bool = False, status: str = 'New', 
                                    decision: Optional[str] = None, remarks: Optional[str] = None,
                                    customer_full_name: Optional[str] = None # NEW: Accept customer_full_name
                                    ) -> int:
        def _sync_insert():
            with get_db_connection() as conn:
                with get_db_cursor(conn) as cur:
                    # Default values for new case_main columns short_dn, long_dn, decision_type
                    # These can be refined based on case_type later or passed as parameters
                    default_short_dn = None
                    default_long_dn = None
                    default_decision_type = None

                    cur.execute("""
                        INSERT INTO public.case_main (
                            case_type, source_ack_no, cust_id, acc_num, source_bene_accno, 
                            is_operational, status, creation_date, creation_time,
                            decision, remarks, short_dn, long_dn, decision_type -- New columns
                        )
                        VALUES (%s, %s, %s, %s, %s, %s, %s, CURRENT_DATE, CURRENT_TIME, %s, %s, %s, %s, %s)
                        RETURNING case_id;
                    """, (
                        case_type, source_ack_no, cust_id, acc_num, source_bene_accno,
                        is_operational, status,
                        decision, remarks,
                        default_short_dn, default_long_dn, default_decision_type # Pass defaults for new columns
                    ))
                    new_case_id = cur.fetchone()['case_id']
                    conn.commit()
                    return new_case_id
        return await self._execute_sync_db_op(_sync_insert)

    
    # --- OLD TABLE INSERTIONS (Will be removed/phased out in future steps) ---
    async def insert_case_master(self, ack_no, cust_id, complaint_type, source, location, transaction_amount):
        def _sync_insert_master():
            with get_db_connection() as conn:
                with get_db_cursor(conn) as cur:
                    today = date.today()
                    cur.execute("""
                        INSERT INTO case_master (ack_no, cust_id, complaint_type, source,
                        location, transaction_amount, status, created_on,
                        closed_on, decision, remarks)
                        VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
                        RETURNING case_id
                    """, (
                        ack_no, cust_id, complaint_type, source,
                        location, transaction_amount, 'New', today,
                        None, None, None
                    ))
                    case_id_result = cur.fetchone()
                    conn.commit()
                    return case_id_result['case_id']
        return await self._execute_sync_db_op(_sync_insert_master)

    async def insert_case_details(self, case_id, cust_id, complaint_date, mobile, email, pan, nat_id, card_num, acct_num, txn_ref_id):
        def _sync_insert_details():
            with get_db_connection() as conn:
                with get_db_cursor(conn) as cur:
                    cur.execute("""
                        INSERT INTO case_detail (case_id, cust_id, comp_date, mobile, email, pan, aadhar, card, acct, txn_id)
                        VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
                    """, (case_id, cust_id, complaint_date, mobile or None, email or None, pan or None, nat_id or None, card_num or '', acct_num or '', txn_ref_id or ''))
                    conn.commit()
        return await self._execute_sync_db_op(_sync_insert_details)

    async def insert_case_decisions(self, ack_no: str, classification_result: dict): # Old case_decisions table
        def _sync_insert_decisions():
            with get_db_connection() as conn:
                with get_db_cursor(conn) as cur:
                    classification = classification_result.get("classification"); reason = classification_result.get("reason")
                    decision_action = classification; system_explanation = reason; comments = reason
                    try:
                        cur.execute("""
                            INSERT INTO public.case_decisions (
                                ack_no, risk_score, triggering_rules, comments, decision_action,
                                assigned_employee, audit_trail, system_recommendation, system_explanation
                            ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s)
                        """, (
                            ack_no, None, None, comments, decision_action,
                            None, None, decision_action, system_explanation
                        ))
                        conn.commit()
                        print(f"✅ Decision for ack_no {ack_no} inserted into case_decisions.", flush=True)
                    except Exception as e:
                        conn.rollback()
                        print(f"❌ Error inserting decision for ack_no {ack_no}: {e}", flush=True)
                        raise
        return await self._execute_sync_db_op(_sync_insert_decisions)

    # --- METHODS THAT INTERACT WITH NEW TABLES OR ARE GENERAL ---

    async def fetch_user_type(self, user_name: str) -> Optional[str]:
        def _sync_fetch_user_type():
            with get_db_connection() as conn:
                with get_db_cursor(conn) as cur:
                    cur.execute("SELECT user_type FROM user_table WHERE user_name = %s", (user_name,))
                    result = cur.fetchone()
                    return result['user_type'] if result else None
        return await self._execute_sync_db_op(_sync_fetch_user_type)

    # UPDATED: fetch_dashboard_cases to query new case_main and assignment tables
    async def fetch_dashboard_cases(self, skip: int = 0, limit: int = 25, 
                                    search_ack_no: Optional[str] = None, # Note: this will now search source_ack_no
                                    status_filter: Optional[str] = None,
                                    current_logged_in_username: Optional[str] = None 
                                    ) -> List[Dict[str, Any]]:
        def _sync_fetch_dashboard_cases():
            with get_db_connection() as conn:
                with get_db_cursor(conn) as cur:
                    # FIX: Query new case_main and assignment tables
                    sql_query = """
                        SELECT
                            cm.source_ack_no AS ack_no, -- Alias source_ack_no to ack_no for frontend compatibility
                            cm.case_type AS complaint_type, -- Map case_type to complaint_type
                            cm.case_type AS match_type, -- Map case_type to match_type (Case Label)
                            cm.status,
                            cm.creation_time,
                            cm.creation_date AS created_on, -- Alias creation_date to created_on for frontend
                            a.assigned_to,
                            a.assigned_by
                        FROM public.case_main AS cm
                        LEFT JOIN public.assignment AS a ON cm.case_id = a.case_id
                    """
                    params = []
                    where_clauses = []

                    if search_ack_no:
                        # FIX: Search on source_ack_no in case_main
                        where_clauses.append("cm.source_ack_no ILIKE %s")
                        params.append(f"%{search_ack_no}%")

                    if status_filter:
                        # FIX: Filter on status in case_main
                        where_clauses.append("cm.status = %s")
                        params.append(status_filter)

                    # Role-based filtering logic using user_type from user_table
                    if current_logged_in_username:
                        user_type_from_db = None
                        cur.execute("SELECT user_type FROM user_table WHERE user_name = %s", (current_logged_in_username,))
                        user_type_result = cur.fetchone()
                        if user_type_result:
                            user_type_from_db = user_type_result.get('user_type')

                        if user_type_from_db == 'CRO':
                            pass # CROs see ALL cases.
                        elif user_type_from_db == 'risk_officer':
                            where_clauses.append("a.assigned_to = %s") # Filter by assigned_to in assignment table
                            params.append(current_logged_in_username)
                        elif user_type_from_db == 'others':
                            where_clauses.append("a.assigned_to = %s") # Filter by assigned_to in assignment table
                            params.append(current_logged_in_username)
                        else:
                            where_clauses.append("FALSE") # User not found or unhandled type, show nothing
                    else:
                        pass # Show all by default if no user is authenticated

                    if where_clauses:
                        sql_query += " WHERE " + " AND ".join(where_clauses)

                    sql_query += " ORDER BY cm.creation_date DESC, cm.creation_time DESC" # Order by new creation date/time
                    sql_query += f" LIMIT %s OFFSET %s"
                    params.append(limit)
                    params.append(skip)

                    cur.execute(sql_query, tuple(params))
                    return cur.fetchall()
        return await self._execute_sync_db_op(_sync_fetch_dashboard_cases)


    # This is a general method, now renamed to clearly indicate it fetches from NEW tables.
    async def fetch_new_cases_list(self, skip: int = 0, limit: int = 25, 
                                   search_source_ack_no: Optional[str] = None, 
                                   status_filter: Optional[str] = None,
                                   current_logged_in_username: Optional[str] = None, 
                                   current_logged_in_user_type: Optional[str] = None 
                                   ) -> List[Dict[str, Any]]:
        def _sync_fetch_new_cases_list():
            with get_db_connection() as conn:
                with get_db_cursor(conn) as cur:
                    sql_query = """
                        SELECT
                            cm.case_id,
                            cm.case_type,
                            cm.source_ack_no,
                            cm.status,
                            cm.creation_date,
                            a.assigned_to,
                            a.assigned_by
                        FROM case_main AS cm
                        LEFT JOIN assignment AS a ON cm.case_id = a.case_id
                    """
                    params = []
                    where_clauses = []

                    if search_source_ack_no:
                        where_clauses.append("cm.source_ack_no ILIKE %s")
                        params.append(f"%{search_source_ack_no}%")

                    if status_filter:
                        where_clauses.append("cm.status = %s")
                        params.append(status_filter)

                    if current_logged_in_username and current_logged_in_user_type:
                        if current_logged_in_user_type == 'CRO':
                            pass
                        elif current_logged_in_user_type == 'risk_officer':
                            where_clauses.append("a.assigned_to = %s")
                            params.append(current_logged_in_username)
                        elif current_logged_in_user_type == 'others':
                            where_clauses.append("a.assigned_to = %s")
                            params.append(current_logged_in_username)
                        else:
                            where_clauses.append("FALSE")
                    else:
                        pass

                    if where_clauses:
                        sql_query += " WHERE " + " AND ".join(where_clauses)

                    sql_query += " ORDER BY cm.creation_date DESC, cm.creation_time DESC"
                    sql_query += f" LIMIT %s OFFSET %s"
                    params.append(limit)
                    params.append(skip)

                    cur.execute(sql_query, tuple(params))
                    return cur.fetchall()
        return await self._execute_sync_db_op(_sync_fetch_new_cases_list)

    # NEW METHOD: Fetch detailed case info from new tables (for /api/new-case-details/{case_id})
    async def fetch_new_case_details(self, case_id: int) -> Optional[Dict[str, Any]]:
        def _sync_fetch_new_case_details():
            with get_db_connection() as conn:
                with get_db_cursor(conn) as cur:
                    sql_query = """
                        SELECT
                            cm.*, -- Select all columns from case_main
                            a.assigned_to, a.assigned_by, a.assign_date, a.assign_time, -- From assignment
                            d.remarks AS decision_remarks, d.short_dn, d.long_dn, d.decision_type, d.decision_by, d.created_time AS decision_created_time -- From new decision table
                        FROM public.case_main AS cm
                        LEFT JOIN public.assignment AS a ON cm.case_id = a.case_id
                        LEFT JOIN public.case_history AS d ON cm.case_id = d.case_id -- Use case_history
                        WHERE cm.case_id = %s
                    """
                    cur.execute(sql_query, (case_id,))
                    result = cur.fetchone()
                    return result
        
        try:
            return await self._execute_sync_db_op(_sync_fetch_new_case_details)
        except CaseNotFoundError:
            raise
        except Exception as e:
            print(f"Error fetching new case details for ID {case_id}: {e}", flush=True)
            raise

    # NEW METHOD: Fetch combined case data from various tables
    async def fetch_combined_case_data(self, case_id: int) -> Optional[Dict[str, Any]]:
        def _sync_fetch_combined_data():
            with get_db_connection() as conn:
                with get_db_cursor(conn) as cur:
                    combined_case_data = {}

                    # 1. Fetch base case details from case_main
                    cur.execute("""
                        SELECT
                            case_id, case_type, source_ack_no, source_bene_accno,
                            acc_num, cust_id, creation_date, creation_time, is_operational, status,
                            short_dn, long_dn, decision_type -- NEW: Add new columns from case_main
                        FROM public.case_main
                        WHERE case_id = %s
                    """, (case_id,))
                    case_main_data = cur.fetchone()
                    if not case_main_data:
                        raise CaseNotFoundError(f"Case with ID {case_id} not found in case_main.")
                    combined_case_data.update(case_main_data)

                    source_ack_no = case_main_data.get('source_ack_no')
                    main_cust_id = case_main_data.get('cust_id')
                    main_acc_num = case_main_data.get('acc_num')
                    source_bene_accno = case_main_data.get('source_bene_accno')

                    # 2. Fetch I4C data from case_entry_form (linked by source_ack_no)
                    if source_ack_no:
                        cur.execute("""
                            SELECT
                                ack_no, sub_category, transaction_date, complaint_date, report_datetime,
                                state, district, policestation, payment_mode, account_number, card_number,
                                transaction_id, layers, transaction_amount, disputed_amount, action,
                                to_bank, to_account, ifsc, to_transaction_id, to_amount, action_taken_date,
                                lien_amount, evidence, evidence_name, additional_info, to_upi_id
                            FROM case_entry_form
                            WHERE ack_no = %s
                        """, (source_ack_no,))
                        i4c_data = cur.fetchone()
                        if i4c_data:
                            combined_case_data['i4c_data'] = i4c_data
                        else:
                            combined_case_data['i4c_data'] = None

                    # 3. Fetch customer details (victim/primary)
                    customer_data = None
                    if main_cust_id:
                        cur.execute("""
                            SELECT cust_id, fname, mname, lname, mobile, email, pan, aadhar, dob, citizen, occupation, seg, cust_type, risk_prof, kyc_status
                            FROM customer WHERE cust_id = %s
                        """, (main_cust_id,))
                        customer_data = cur.fetchone()
                    combined_case_data['customer_details'] = customer_data

                    # 4. Fetch account details (primary account from case_main)
                    account_details = None
                    if main_acc_num:
                        cur.execute("""
                            SELECT acc_num, acc_name, acc_type, acc_status, open_date, branch_code, currency, balance, prod_code, min_bal, od_limit, credit_score, aqb, interest_rate, last_txn_date
                            FROM account WHERE acc_num = %s
                        """, (main_acc_num,))
                        account_details = cur.fetchone()
                    combined_case_data['account_details'] = account_details
                    
                    # 5. Fetch transaction details (based on acc_num and source_bene_accno)
                    transactions = []
                    tx_acc_nums_to_check = []
                    if main_acc_num: tx_acc_nums_to_check.append(main_acc_num)
                    if source_bene_accno and source_bene_accno != main_acc_num: tx_acc_nums_to_check.append(source_bene_accno)

                    if tx_acc_nums_to_check:
                        cur.execute("""
                            SELECT acc_num, txn_date, txn_time, txn_type, amount, descr, txn_ref, currency, bene_name, bene_acct_num, pay_method, channel
                            FROM txn
                            WHERE acc_num IN %s
                            ORDER BY txn_date DESC, txn_time DESC
                        """, (tuple(tx_acc_nums_to_check),))
                        transactions = cur.fetchall()
                    combined_case_data['transactions'] = transactions

                    # 6. Fetch decision history from the new 'case_history' table
                    cur.execute("""
                        SELECT remarks, short_dn, long_dn, decision_type, decision_by AS updated_by, created_time
                        FROM public.case_history -- Use case_history table
                        WHERE case_id = %s
                        ORDER BY created_time DESC
                    """, (case_id,))
                    decision_history = cur.fetchall()
                    combined_case_data['decision_history'] = decision_history

                    # 7. Fetch assignment history from the new 'assignment' table
                    cur.execute("""
                        SELECT assigned_to, assigned_by, assign_date, assign_time
                        FROM public.assignment
                        WHERE case_id = %s
                        ORDER BY assign_date DESC, assign_time DESC
                    """, (case_id,))
                    assignment_history = cur.fetchall()
                    combined_case_data['assignment_history'] = assignment_history

                    # 8. Fetch documents from the new 'case_documents' table (using integer case_id)
                    uploaded_documents = []
                    cur.execute("""
                        SELECT id, document_type, original_filename, file_location, uploaded_by, comment, uploaded_at, file_mime_type
                        FROM public.case_documents
                        WHERE case_id = %s
                        ORDER BY uploaded_at DESC
                    """, (case_id,)) # case_documents.case_id is now integer
                    uploaded_documents = cur.fetchall()
                    combined_case_data['uploaded_documents'] = uploaded_documents

                    return combined_case_data

        try:
            return await self._execute_sync_db_op(_sync_fetch_combined_data)
        except CaseNotFoundError:
            raise
        except Exception as e:
            print(f"Error fetching combined case data for case_id {case_id}: {e}", flush=True)
            raise


# --- DatabaseMatcher Class (Currently not used for new table logic, can be removed if desired) ---
class DatabaseMatcher:
    def __init__(self, executor: ThreadPoolExecutor):
        self.executor = executor

    async def _execute_sync_db_op(self, func, *args, **kwargs):
        return await asyncio.get_running_loop().run_in_executor(self.executor, func, *args, **kwargs)
